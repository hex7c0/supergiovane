"use strict";

function bootstrap(my) {
    var app = express();
    app.set("env", my.env), "production" == my.env ? app.enable("view cache") : app.disable("view cache"), 
    app.enable("case sensitive routing"), app.enable("trust proxy"), app.disable("x-powered-by"), 
    my.logger && app.use(logger(my.logger)), my.timeout && app.use(require("timeout-request")(my.timeout)), 
    my.signature && app.use(require("server-signature")(my.signature)), my.sitemap && require("express-sitemap")(my.sitemap).toFile(), 
    my.mamma && require("mamma").createClient(my.mamma, process.pid + "supergiovane").on("error", function(err) {
        return debug("cluster", {
            pid: process.pid,
            status: "mamma",
            error: err.message
        });
    }), app.use(require("compression-zlib")());
    var cache;
    cache = my.cache ? function(bod, hash, cont) {
        if (void 0 === STORY[hash]) {
            var last, c = 0, old = Date.now();
            for (var pr in STORY) c++, STORY[pr].time < old && (last = pr, old = STORY[last].time);
            c >= my.cache && delete STORY[last], STORY[hash] = {
                content: cont,
                body: bod,
                time: Date.now()
            };
        }
    } : function() {};
    var httpAgent = new http.Agent({
        keepAlive: !0
    }), STORY = Object.create(null), index = resolve(my.dir + "index.min.html");
    if (app.get("/:pkg/:extra?", function(req, res, next) {
        var version = "/", r = req.headers.referer || req.headers.referrer, p = req.params.pkg, e = req.params.extra || "", s = req.query.style ? "?style=" + req.query.style : "", hash = p + e + s;
        if (my.referer.test(r) === !1 && "badge.svg" !== e) return res.redirect(301, my.referer.source);
        if (my.cache !== !1 && void 0 !== STORY[hash]) return Date.now() - STORY[hash].time > my.flush && delete STORY[hash], 
        setHeader(res, "Content-Type", STORY[hash].content) === !0 ? res.status(202).send(STORY[hash].body) : null;
        if ("" !== e) if ("badge.svg" === e) ; else {
            if (!semver.valid(e)) return next(new Error(status[404]));
            version += e;
        }
        return http.get({
            host: "registry.npmjs.org",
            path: "/" + p + version,
            agent: httpAgent,
            headers: {
                "User-Agent": VERSION
            }
        }, function(inp) {
            var body = new Buffer(0);
            return 200 !== inp.statusCode ? next(new Error(status[404])) : void inp.on("data", function(chunk) {
                body += chunk;
            }).on("end", function() {
                if (body = JSON.parse(body), body.readme = null, "badge.svg" === e) {
                    var c = Object.keys(body.versions).length, plu = c > 1 ? "s-" : "-";
                    http.get({
                        host: "img.shields.io",
                        path: "/badge/version" + plu + c + "-red.svg" + s,
                        agent: httpAgent,
                        headers: {
                            "User-Agent": VERSION
                        }
                    }, function(inp) {
                        var badge = new Buffer(0);
                        return 200 !== inp.statusCode ? next(new Error(status[404])) : void inp.on("data", function(chunk) {
                            badge += chunk;
                        }).on("end", function() {
                            var content = "image/svg+xml; charset=utf-8";
                            res.set("Content-Type", content), res.send(badge), cache(badge, hash, content);
                        }).on("error", function(err) {
                            return next(new Error(status[404])), debug("client", {
                                pid: process.pid,
                                status: "response",
                                error: err.message
                            });
                        });
                    }).on("error", function(err) {
                        return next(new Error(status[404])), debug("client", {
                            pid: process.pid,
                            status: "response",
                            error: err.message
                        });
                    });
                } else {
                    var content = "application/json; charset=utf-8";
                    res.set("Content-Type", content), res.send(body), cache(body, hash, content);
                }
            });
        }).on("error", function(err) {
            return next(new Error(status[404])), debug("client", {
                pid: process.pid,
                status: "request",
                error: err.message
            });
        });
    }), app.get("/", function(req, res) {
        return res.sendFile(index);
    }), app.use(function(err, req, res, next) {
        var out = "", error = err.message.toLowerCase(), code = 500;
        switch (debug("web", {
            pid: process.pid,
            status: "catch",
            error: error
        }), error) {
          case "not found":
            return next();

          default:
            "production" !== my.env && (out = error);
        }
        res.status(code).json({
            error: out
        });
    }), app.use(function(req, res) {
        var code = 404;
        res.status(code).json({
            error: status[code].toLowerCase()
        });
    }), "test" != my.env) {
        "production" != my.env && console.log(process.pid + " | listening on: " + my.host + ":" + my.port), 
        debug("web", {
            pid: process.pid,
            host: my.host,
            port: my.port
        });
        var server = http.createServer(app);
        my.timeout && my.timeout.milliseconds && (server.timeout = my.timeout.milliseconds), 
        server.listen(my.port, my.host);
    }
    return app;
}

var cluster = require("cluster"), http = require("http"), resolve = require("path").resolve, status = http.STATUS_CODES, express = require("express"), logger = require("logger-request"), semver = require("semver"), setHeader = require("setheaders").setWritableHeader, VERSION = JSON.parse(require("fs").readFileSync(__dirname + "/package.json"));

VERSION = VERSION.name + "@" + VERSION.version;

var debug = function() {};

module.exports = function(opt) {
    var options = opt || Object.create(null), my = {
        env: String(options.env || "production"),
        host: String(options.host || "127.0.0.1"),
        port: Number(options.port) || 3e3,
        referer: new RegExp(String(options.referer || "http://127.0.0.1"), "i"),
        dir: String(options.dir || __dirname + "/public/"),
        logger: options.logger === !1 ? !1 : options.logger || {
            filename: "route.log"
        },
        timeout: options.timeout === !1 ? !1 : options.timeout || {},
        sitemap: options.sitemap === !1 ? !1 : options.sitemap || {},
        signature: options.signature === !1 ? !1 : options.signature || !1,
        cache: options.cache === !1 ? !1 : Number(options.cache) || 6,
        flush: Number(options.flush) || 864e5,
        fork: Number(opt.fork) < 5 ? require("os").cpus().length : Number(opt.fork) || require("os").cpus().length,
        max: "string" == typeof opt.max ? opt.max : Number(opt.max) || 0,
        debug: options.debug === !1 ? !1 : options.debug || "debug.log",
        task: Boolean(options.task) ? options.task : !1,
        mamma: Boolean(options.mamma) ? options.mamma : !1
    };
    if (my.debug && (debug = logger({
        filename: my.debug,
        standalone: !0,
        winston: {
            logger: "_spDebug",
            level: "debug",
            json: !1
        }
    })), cluster.isMaster) {
        if (my.task && require("task-manager")(my.task), "production" != my.env) return bootstrap(my);
        for (var i = 0; i < my.fork; i++) cluster.fork();
        return void cluster.on("exit", function(worker, code, signal) {
            debug("cluster", {
                pid: worker.process.pid,
                status: code || signal,
                suicide: worker.suicide,
                max: my.max
            }), worker.suicide === !0 ? cluster.fork() : (isNaN(my.max) === !0 || my.max-- > 0) && cluster.fork();
        });
    }
    return process.on("uncaughtException", function(err) {
        return debug("cluster", {
            pid: process.pid,
            status: "uncaughtException",
            error: err.message,
            stack: err.stack
        }), setTimeout(function() {
            return process.exit(1);
        }, 250);
    }), bootstrap(my);
};
