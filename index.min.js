"use strict";

function bootstrap(my) {
    var app = express();
    app.set("env", my.env), "production" == my.env ? app.enable("view cache") : app.disable("view cache"), 
    app.enable("case sensitive routing"), app.enable("trust proxy"), app.disable("x-powered-by"), 
    my.logger && app.use(logger(my.logger)), my.timeout && app.use(require("timeout-request")(my.timeout)), 
    my.signature && app.use(require("server-signature")(my.signature)), my.sitemap && require("express-sitemap")(my.sitemap).toFile(), 
    my.mamma && require("mamma").createClient(my.mamma, process.pid + ":supergiovane").on("error", function(err) {
        debug("cluster", {
            pid: process.pid,
            status: "mamma",
            error: err.message
        });
    }), app.use(require("compression-zlib")());
    var cache;
    cache = my.cache ? function(bod, hash, cont) {
        if (void 0 === STORY[hash]) {
            var last, c = 0, old = Date.now();
            for (var pr in STORY) c++, STORY[pr].time < old && (last = pr, old = STORY[last].time);
            c >= my.cache && delete STORY[last], STORY[hash] = {
                content: cont,
                body: bod,
                time: Date.now()
            };
        }
    } : function() {};
    var httpsAgent = new https.Agent({
        keepAlive: !0
    }), STORY = Object.create(null), index = resolve(my.dir + "index.min.html");
    if (app.get("/api/:pkg/:extra?", function(req, res, next) {
        var isBadge = !1, version = "/", pkg = req.params.pkg, extra = req.params.extra || "", s = req.query.style ? "?style=" + req.query.style : "", hash = pkg + extra + s;
        if (my.cache !== !1 && STORY[hash]) return Date.now() - STORY[hash].time > my.flush && delete STORY[hash], 
        setHeader(res, "Content-Type", STORY[hash].content) === !0 ? res.status(202).send(STORY[hash].body) : null;
        if ("" !== extra) if ("badge.svg" === extra) isBadge = !0; else {
            if (!semver.valid(extra)) return next(new Error(status[404]));
            version += extra;
        }
        https.get({
            host: "registry.npmjs.org",
            path: "/" + pkg + version,
            agent: httpsAgent,
            headers: {
                "User-Agent": VERSION
            }
        }, function(inp) {
            if (200 !== inp.statusCode) return next(new Error(status[404]));
            var body = new Buffer(0);
            inp.on("data", function(chunk) {
                body += chunk;
            }).on("end", function() {
                if (body = JSON.parse(body), body.readme = null, isBadge === !0) {
                    var c = Object.keys(body.versions).length, plu = c > 1 ? "s-" : "-";
                    return https.get({
                        host: "img.shields.io",
                        path: "/badge/version" + plu + c + "-red.svg" + s,
                        agent: httpsAgent,
                        headers: {
                            "User-Agent": VERSION
                        }
                    }, function(inp) {
                        if (200 !== inp.statusCode) return next(new Error(status[404]));
                        var badge = new Buffer(0);
                        inp.on("data", function(chunk) {
                            badge += chunk;
                        }).on("end", function() {
                            var content = "image/svg+xml; charset=utf-8";
                            setHeader(res, "Content-Type", content) === !0 && (res.send(badge), cache(badge, hash, content));
                        }).on("error", function(err) {
                            next(new Error(status[404])), debug("client", {
                                pid: process.pid,
                                status: "response",
                                error: err.message
                            });
                        });
                    }).on("error", function(err) {
                        next(new Error(status[404])), debug("client", {
                            pid: process.pid,
                            status: "response",
                            error: err.message
                        });
                    });
                }
                var content = "application/json; charset=utf-8";
                setHeader(res, "Content-Type", content) === !0 && (res.send(body), cache(body, hash, content));
            });
        }).on("error", function(err) {
            next(new Error(status[404])), debug("client", {
                pid: process.pid,
                status: "request",
                error: err.message
            });
        });
    }), app.get("/", function(req, res) {
        res.sendFile(index);
    }), app.use("/static", express.static(my.dir)), app.use(function(err, req, res, next) {
        var code = 500, error = err.message.toLowerCase();
        switch (error) {
          case "not found":
            return next();

          default:
            debug("web", {
                pid: process.pid,
                status: "catch",
                error: error
            }), "production" === my.env && (error = status[code].toLowerCase());
        }
        var out = res.status(code);
        isApi.test(req.url) === !0 ? out.json({
            error: error
        }) : out.end(error);
    }), app.use(function(req, res) {
        var code = 404, error = status[code].toLowerCase(), out = res.status(code);
        isApi.test(req.url) === !0 ? out.json({
            error: error
        }) : out.end(error);
    }), "test" != my.env) {
        "production" != my.env && console.log(process.pid + " | listening on: " + my.host + ":" + my.port), 
        debug("web", {
            pid: process.pid,
            host: my.host,
            port: my.port
        });
        var server = http.createServer(app);
        my.timeout && my.timeout.milliseconds && (server.timeout = my.timeout.milliseconds), 
        server.listen(my.port, my.host);
    }
    return app;
}

var cluster = require("cluster"), https = require("https"), http = require("http"), resolve = require("path").resolve, status = http.STATUS_CODES, express = require("express"), logger = require("logger-request"), semver = require("semver"), setHeader = require("setheaders").setWritableHeader, VERSION = JSON.parse(require("fs").readFileSync(__dirname + "/package.json"));

VERSION = VERSION.name + "@" + VERSION.version;

var isApi = /^\/api(\/)?/i, debug = function() {};

module.exports = function(opt) {
    var options = opt || Object.create(null), my = {
        env: String(options.env || "production"),
        host: String(options.host || "127.0.0.1"),
        port: Number(options.port) || 3e3,
        referer: new RegExp(String(options.referer || "http://127.0.0.1"), "i"),
        dir: String(options.dir || __dirname + "/public/"),
        logger: options.logger !== !1 && (options.logger || {
            filename: "route.log",
            daily: !0
        }),
        timeout: options.timeout !== !1 && (options.timeout || {}),
        sitemap: options.sitemap !== !1 && (options.sitemap || {}),
        signature: options.signature !== !1 && (options.signature || !1),
        cache: options.cache !== !1 && (Number(options.cache) || 6),
        flush: Number(options.flush) || 864e5,
        fork: Number(opt.fork) < 5 ? require("os").cpus().length : Number(opt.fork) || require("os").cpus().length,
        max: "string" == typeof opt.max ? opt.max : Number(opt.max) || 0,
        debug: options.debug !== !1 && (options.debug || "debug.log"),
        task: !!Boolean(options.task) && options.task,
        mamma: !!Boolean(options.mamma) && options.mamma
    };
    if (my.debug && (debug = logger({
        filename: my.debug,
        daily: !0,
        standalone: !0,
        winston: {
            logger: "_spDebug",
            level: "debug",
            json: !1
        }
    })), cluster.isMaster) {
        if (my.task && require("task-manager")(my.task), "production" != my.env) return bootstrap(my);
        for (var i = 0; i < my.fork; i++) cluster.fork();
        cluster.on("exit", function(worker, code, signal) {
            debug("cluster", {
                pid: worker.process.pid,
                status: code || signal,
                suicide: worker.suicide,
                max: my.max
            }), worker.suicide === !0 ? cluster.fork() : (isNaN(my.max) === !0 || my.max-- > 0) && cluster.fork();
        });
    }
    return process.on("uncaughtException", function(err) {
        debug("cluster", {
            pid: process.pid,
            status: "uncaughtException",
            error: err.message,
            stack: err.stack
        }), setTimeout(function() {
            process.exit(1);
        }, 250);
    }), bootstrap(my);
};
